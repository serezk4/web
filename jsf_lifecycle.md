### **JSF: Жизненный цикл**

Жизненный цикл JSF (JavaServer Faces) — это последовательность этапов, которые управляют обработкой HTTP-запросов и рендерингом ответов. Он включает фазы от загрузки страницы до обработки пользовательского ввода и формирования HTML-ответа.

JSF использует **двухфазную модель обработки**:
1. Фаза **обработки запросов**.
2. Фаза **рендеринга ответа**.

---

#### **Основные фазы жизненного цикла**
Жизненный цикл JSF состоит из шести стандартных фаз:

1. **Restore View (Восстановление представления):**
   - В этой фазе JSF восстанавливает дерево компонентов, соответствующее текущей странице.
   - Если пользователь впервые загружает страницу, создаётся новое дерево компонентов.

2. **Apply Request Values (Применение значений запроса):**
   - JSF связывает значения пользовательского ввода с компонентами дерева.
   - Проверяется наличие ошибок, таких как неправильные значения.

3. **Process Validations (Проверка данных):**
   - Валидация значений компонентов. Например, проверяется, является ли введённое значение числом.
   - Если валидация завершается неудачно, переход на фазу рендеринга.

4. **Update Model Values (Обновление модели):**
   - Значения, прошедшие валидацию, записываются в Managed Beans.
   - Эта фаза обновляет состояние модели на сервере.

5. **Invoke Application (Вызов бизнес-логики):**
   - Выполняются действия, связанные с пользовательскими командами (например, нажатие кнопки).
   - Осуществляется переход на другие страницы, если это требуется.

6. **Render Response (Рендеринг ответа):**
   - JSF преобразует дерево компонентов в HTML.
   - Генерируется окончательная страница для отправки клиенту.

---

#### **Подробное описание фаз**

##### 1. **Restore View**
- Цель: Восстановить или создать дерево компонентов.
- Поведение:
  - Если это первый запрос, создаётся новое дерево компонентов.
  - Если это повторный запрос, дерево восстанавливается из сохранённого состояния.
- Код (пример восстановления):
  ```java
  UIViewRoot viewRoot = FacesContext.getCurrentInstance().getViewRoot();
  ```

---

##### 2. **Apply Request Values**
- Цель: Привязать значения из HTTP-запроса к соответствующим компонентам.
- Поведение:
  - Если введённые данные невалидны (например, значение не соответствует ожидаемому формату), процесс пропускает остальные фазы и переходит к рендерингу.
- Пример ошибки:
  ```xml
  <h:inputText id="age" value="#{userBean.age}" required="true" />
  ```

---

##### 3. **Process Validations**
- Цель: Проверить валидность пользовательских данных.
- Поведение:
  - Компоненты, такие как `<h:inputText>` и `<h:selectOneMenu>`, выполняют валидацию.
  - Если валидация не пройдена, в компонент добавляется сообщение об ошибке.
- Пример кода валидации:
  ```java
  @FacesValidator("customValidator")
  public class CustomValidator implements Validator {
      @Override
      public void validate(FacesContext context, UIComponent component, Object value) throws ValidatorException {
          if (value == null || ((String) value).isEmpty()) {
              throw new ValidatorException(new FacesMessage("Value is required!"));
          }
      }
  }
  ```

---

##### 4. **Update Model Values**
- Цель: Передать валидированные значения в Managed Beans.
- Поведение:
  - JSF синхронизирует дерево компонентов с моделью.
  - Ошибки при обновлении могут остановить процесс.

---

##### 5. **Invoke Application**
- Цель: Выполнить бизнес-логику и инициировать навигацию.
- Поведение:
  - Пользовательские команды, такие как нажатие кнопки, обрабатываются в этой фазе.
  - Навигация к другим страницам или выполнение операций над базой данных происходит здесь.
- Пример:
  ```java
  public String save() {
      // Логика сохранения данных
      return "success"; // Имя страницы для перехода
  }
  ```

---

##### 6. **Render Response**
- Цель: Преобразовать дерево компонентов в HTML.
- Поведение:
  - Все компоненты дерева рендерятся в HTML.
  - Если это первый запрос, генерируется новая HTML-страница.
  - Если предыдущие фазы завершились с ошибками, дерево рендерится с сообщениями об ошибках.

---

#### **Диаграмма жизненного цикла**

```plaintext
1. Restore View
   ↓
2. Apply Request Values
   ↓
3. Process Validations
   ↓
4. Update Model Values
   ↓
5. Invoke Application
   ↓
6. Render Response
```

---

#### **Прерывание жизненного цикла**
В определённых ситуациях жизненный цикл может быть прерван:
1. Если валидация данных завершилась неудачно.
2. Если возникли исключения при обновлении модели.

---

#### **Пример кода жизненного цикла**

**XHTML:**
```xml
<h:form>
    <h:outputLabel for="name" value="Enter your name:" />
    <h:inputText id="name" value="#{userBean.name}" required="true" />
    <h:message for="name" />
    <h:commandButton value="Submit" action="#{userBean.submit}" />
</h:form>
```

**Managed Bean:**
```java
import jakarta.inject.Named;
import jakarta.enterprise.context.RequestScoped;

@Named
@RequestScoped
public class UserBean {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String submit() {
        if (name.isEmpty()) {
            return null;
        }
        return "success";
    }
}
```

---

#### **Полезные ссылки для изучения**
1. **JSF Lifecycle Overview:**
   - [Oracle Documentation](https://docs.oracle.com/javaee/7/tutorial/jsf-lifecycle.htm)
2. **JSF Tutorial by Baeldung:**
   - [Baeldung JSF Lifecycle](https://www.baeldung.com/jsf)
3. **PrimeFaces Documentation:**
   - [PrimeFaces Guide](https://www.primefaces.org/documentation)

---

#### **Заключение**
Жизненный цикл JSF обеспечивает мощный механизм управления запросами и ответами, разделяя обработку данных на чёткие фазы. Понимание жизненного цикла является ключевым для разработки сложных JSF-приложений, так как это позволяет эффективно управлять состоянием компонентов и обрабатывать пользовательский ввод.
